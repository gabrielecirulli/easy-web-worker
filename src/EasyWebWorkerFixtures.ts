export const generatedId = (): string =>
  `${Date.now()}${Math.random().toString(36).substring(2, 9)}`;

/**
 * This function contains an obfuscated version of the StaticEasyWebWorker internal auto invocable function, without comments or types
 * this template is used to create dynamic workers from strings templates
 * PLEASE KEEP THIS FUNCTION UPDATED WITH THE LATEST VERSION OF THE StaticEasyWebWorker CLASS
 * [IMPORTANT] Avoid ";" at the end of the template, and dont forget to inject the targetOrigin variable: ({targetOrigin:'${origin}'})
 */
export const getWorkerTemplate = ({ origin = '' }: { origin: string }) => {
  const template = `(e=>{let t=new Map,a=new Map([["",()=>{throw"you didn't define a message-callback, please assign a callback by calling IEasyWorkerInstance.onMessage"},],]),o=({messageId:e,payload:a,method:o,origin:r})=>{let s=new Set,n="pending",l=(a,s)=>{let l=n,c=a.resolved?"resolved":a.rejected?"rejected":a.worker_cancelation?"canceled":n;if(!t.has(e)){let i="%c#"+e+" Message Not Found: %cThis means that the message was already resolved | rejected | canceled. To avoid this error, please make sure that you are not resolving | rejecting | canceling the same message twice. Also make sure that you are not reporting progress after the message was processed. Remember each message can handle his one cancelation by adding a handler with the %cmessage.onCancel%c method. To now more about this method, please check the documentation at: %chttps://www.npmjs.com/package/easy-web-worker#ieasywebworkermessageipayload--null-iresult--void %cTrying to process message:";console.error(i,"color: darkorange; font-size: 12px; font-weight: bold;","font-weight: normal;","font-weight: bold;","font-weight: normal;","color: lightblue; font-size: 10px; font-weight: bold;","font-weight: bold; color: darkorange;",{messageId:e,status:{current:l,target:c},method:o,action:a});return}let{progress:d}=a;d||t.delete(e),self.postMessage({messageId:e,...a},r,s),n=c},c=(e,t)=>{l({resolved:{payload:void 0===e?[]:[e]}},t)},i=e=>{l({rejected:{reason:e}},[])},d=e=>{let t=[...s];t.forEach(t=>t(e)),l({worker_cancelation:{reason:e}},[])},g=(e,t,a)=>{l({progress:{percentage:e,payload:t}},a)},h=e=>(s.add(e),()=>s.delete(e));return{messageId:e,getStatus:()=>n,isPending:()=>"pending"===n,method:o,payload:a,resolve:c,reject:i,cancel:d,onCancel:h,reportProgress:g}},r=(...e)=>{let[t,o]=e,r="string"==typeof t;if(r){let s=t,n=o;a.set(s,n);return}let l=t;a.set("",l)},s=()=>{let e=[...t.values()];e.forEach(e=>e.reject(Error("worker closed"))),self.close()};self.onmessage=r=>{let{data:s,origin:n}=r,{messageId:l,cancelation:c}=s;if(c){let i=t.get(l);i&&i.cancel(c.reason);return}let{method:d,execution:g}=s,{payload:h}=g,w=o({method:d,messageId:l,payload:h,origin:e||n||void 0});t.set(l,w);let m=a.get(d||"");m&&m(w,r)};let n=(...e)=>{self.importScripts(...e)};return{onMessage:r,close:s,importScripts:n}})('${origin}')`;

  return template;
};
